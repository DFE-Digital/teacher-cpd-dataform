config {
    type: "incremental",
    tags: ["kpi"],
    assertions: {
        uniqueKey: ["date", "entity_table_name", "fields_updated", "correction_type"]
    },
    bigquery: {
        partitionBy: "date",
        labels: {
            usage: "kpi"
        }
    },
    description: "Single-dimension cube (by date) containing aggregable ECF1 data correction metrics. A correction is defined under the metadata for the number_of_corrections field. To enable calculation of correction KPI & breakdowns. Data is only available from September 2023 onwards because dfe-analytics was not installed on Manage before this date.",
    columns: {
        date: "Date for which these metrics have been calculated",
        entity_table_name: "The table which was updated on this date",
        fields_updated: "Field(s) which was updated as part of this updated. Formatted as an ' and ' separated list in a string.",
        correction_type: "Clawed back declaration, Voided declaration, Admin console (where request_path starts with /admin or /finance) or Update made without user agent.",
        registration_window_start_date: "The first date in the registration window this date falls within",
        registration_window_string: "Registration window date falls within formatted as e.g. 2032-33 for display purposes",
        registration_window: "Calendar year registration_window_start_date falls within e.g. 2032 for the 2032-33 registration window",
        registration_window_day: "Number of days within registration window that this date is since the registration_year_start_date, counting registration_year_start_date as day 1.",
        registration_window_week: "Week of registration window that this date falls within, treating the registration_year_start_date as day 1 of week 1.",
        registration_window_month: "Month of registration window that this date falls within, treating the registration_year_start_date as day 1 of month 1. An integer. For example, if a registration window started on Dec 25th 2056, Dec 27th 2056 falls in month 1, Jan 5th 2056 falls in month 1, Jan 25th 2057 falls in month 2 etc.",
        date_is_in_registration_window_to_date_or_past_registration_window: "TRUE if date is either between the start date of the current registration window and today's date, or falls within a registration window that ended on a past date. For use to filter metrics on dashboards which are calculated for the 'registration window to date'.",
        date_is_comparable_to_next_registration_window_to_date: "TRUE if the date with the same registration_window_day in the following registration window (i.e. the one after the registration_window date falls within) is between the start date of the current registration window and today's date, or if that date falls within a registration window that ended on a past date. For example, if two consecutive registration windows were 2nd Feb 2057 - 6th March 2058 and 7th March 2058 - 28th Feb 2059, and the current date is 8th March 2058 (registration_window_day = 2), this field would be TRUE for 2nd & 3rd Feb 2057 but FALSE after that. For use to filter metrics on dashboards which are calculated for the 'registration window to date' and then compared with the 'same period last registration window'.",
        number_of_live_ects_baseline_estimate: "Best available actual or estimated number of live ECTs (according to RIAB) to use as a baseline in the registration window that date falls within. Live is defined as having induction recorded in RIAB where the period between the start and end dates overlaps with the first academic year that starts after the registration window begins. To act as a baseline across a range of KPIs. Note that these KPIs should be defined with the baseline (denominator) applying to the whole registration window, even if the numerator applies only to a particular day, week, month etc. RIAB data is used because it has significantly higher data quality than Manage. For the current registration window, data is not complete enough until late October, so this is set to the value from the previous registration window until 1st November.",
        number_of_corrections: "Number of corrections made of type 'correction_type' to the 'fields_updated' fields in table 'entity_table_name' on 'date'. A correction is a set of updates to fields on a single entity that took place at exactly the same time that represent either a developer updating the database manually, a response to a web request handled by the admin console (paths beginning /admin or /finance), or a status change on a declaration to voided or awaiting_clawback."
    }
}

WITH
  correction AS ( (
  /* Group updates for different fields which happened as part of the same update together so we don't double count them and can see the combinations of fields that get updated together */
    SELECT
      entity_table_name,
      update_id,
      occurred_at,
      request_path,
      request_user_agent,
      new_value,
      previous_value,
      ARRAY_AGG(key_updated
      ORDER BY
        key_updated ASC) AS fields_updated
    FROM
      ${ref(`ecf1_entity_field_updates`)}
    LEFT JOIN
      UNNEST(new_data) AS DATA
    ON
      data.key = "type"
    WHERE
      DATE(occurred_at) > event_date_checkpoint
      AND DATE(occurred_at) < CURRENT_DATE
      AND (request_path LIKE ANY ("/admin%",
          "/finance%")
        OR LOWER(request_user_agent) IS NULL
        OR (entity_table_name = "participant_declarations"
          AND key_updated = "state"
          AND new_value IN ("awaiting_clawback", "voided")
          AND NOT ("ParticipantDeclaration::NPQ" IN UNNEST(data.value))))
      /* Exclude updates which are very likely to be automated activity, and so not manual developer data corrections */
      AND entity_table_name NOT IN ("analytics_participants",
        "emails",
        "nomination_emails",
        "schools")
      AND NOT (entity_table_name = "induction_records" AND key_updated = "end_date")
      /* Exclude state transitions that are expected, so we only include state transitions between states that should not be allowed and so must have been done manually */
      AND NOT (entity_table_name IN ("participant_declarations", "statement_line_items") AND key_updated = "state" AND (
        (previous_value = "submitted" AND new_value = "eligible")
        OR (previous_value = "submitted" AND new_value = "ineligible")
        OR (previous_value = "eligible" AND new_value = "payable")
        OR (previous_value = "payable" AND new_value = "paid")
        OR (previous_value = "awaiting_clawback" AND new_value = "clawed_back")
      ))
    GROUP BY
      ALL)),
  correction_metrics AS (
  SELECT
    DATE(occurred_at) AS date,
    entity_table_name,
    ARRAY_TO_STRING(fields_updated, " and ") AS fields_updated,
    CASE
      WHEN entity_table_name = "participant_declarations" AND "state" IN UNNEST(fields_updated) AND new_value = "awaiting_clawback" THEN "Clawed back declaration"
      WHEN entity_table_name = "participant_declarations"
    AND "state" IN UNNEST(fields_updated)
    AND new_value = "voided" THEN "Voided declaration"
      WHEN request_path LIKE ANY ("/admin%", "/finance%") THEN IF((previous_value = "" OR previous_value IS NULL) AND new_value IS NOT NULL AND new_value != "", "Update from blank/null", "Update to existing value") || " via admin console"
      WHEN LOWER(request_user_agent) IS NULL THEN IF((previous_value = "" OR previous_value IS NULL) AND new_value IS NOT NULL AND new_value != "", "Update from blank/null", "Update to existing value") || " not linked to web request"
      ELSE "Unknown"
  END
    AS correction_type,
    COUNT(*) AS number_of_corrections
  FROM
    correction
  GROUP BY
    date,
    correction_type,
    entity_table_name,
    fields_updated )
SELECT
  dates.date,
  entity_table_name,
  fields_updated,
  correction_type,
  registration_window_start_date,
  registration_window_year,
  registration_window_string,
  registration_window_day,
  registration_window_week,
  registration_window_month,
  date_is_in_registration_window_to_date_or_past_registration_window,
  /* We don't have complete registration windows' data until 2024-25 onwards for web analytics based KPIs so don't enable comparison until then */
IF
  (registration_window_year >= 2024, date_is_comparable_to_next_registration_window_to_date, FALSE) AS date_is_comparable_to_next_registration_window_to_date,
  number_of_live_ects_baseline_estimate,
  IFNULL(number_of_corrections, 0) AS number_of_corrections
FROM
  ${ref("ls_ecf_kpi_live_participants_baseline_cube")} AS dates
LEFT JOIN
  correction_metrics
ON
  dates.date = correction_metrics.date
WHERE
  dates.date > event_date_checkpoint
  AND dates.date < CURRENT_DATE

pre_operations {
  DECLARE
    event_date_checkpoint DEFAULT (
    ${
        when(incremental(),
            `SELECT MAX(date) FROM ${self()}`,
            /* Start calculating at the point of dfe-analytics installation on Manage, because no data is available before then */
            `SELECT DATE("2023-09-18")`)
    }
    )
}

post_operations {
  /* This query is an incremental query, so the output is usually only updated for new days, not past dates. */
    /* However the date_is_in_registration_window_to_date_or_past_registration_window and date_is_comparable_to_next_registration_window_to_date fields vary depending on what the current date is. */
    /* So, implementing this incremental query would mean that these fields contain out of date values for past dates. */
    /* This post operation updates these from the baseline, even for past dates. */
    /* It doesn't add significantly to the bytes queried by the overall query because it doesn't reference the events table, where 99% of these bytes come from. */
  UPDATE
    ${self()} AS ls_ecf_kpi_correction_cube
  SET
    date_is_in_registration_window_to_date_or_past_registration_window = dates.date_is_in_registration_window_to_date_or_past_registration_window,
    date_is_comparable_to_next_registration_window_to_date = dates.date_is_comparable_to_next_registration_window_to_date
  FROM
    ${ref(`ls_ecf_kpi_live_participants_baseline_cube`)} AS dates
  WHERE
    ls_ecf_kpi_correction_cube.date = dates.date
}
